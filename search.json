[{"categories":null,"content":"En esta segunda parte voy a cubrir ORDER BY, BETWEEN, LIMIT, funciones agregadas, GROUP BY, DISTINCT y HAVING para llevar tus consultas al siguiente nivel.","date":"2025-11-13","objectID":"/posts/fundamentos-sql-parte-2/","tags":["SQL","Bases de Datos","Curso SQL"],"title":"Curso de SQL - Notas 2: Consultas Avanzadas y Agregaciones","uri":"/posts/fundamentos-sql-parte-2/"},{"categories":null,"content":"Seguimos con la segunda parte del curso de SQL. En el post anterior vimos las operaciones básicas, y ahora vamos a profundizar en cómo consultar y analizar datos de forma más efectiva. Para los ejemplos voy a seguir usando la tabla usuarios que creamos antes, pero vamos a agregar algunos datos más para que tenga sentido usar estas funciones. ORDER BY\rORDER BY ordena los resultados según una o más columnas. Por defecto ordena de forma ascendente (ASC), también podés usar DESC para orden descendente: -- Ordenar por edad (menor a mayor) SELECT nombre, edad FROM usuarios ORDER BY edad; -- Ordenar de mayor a menor SELECT nombre, edad FROM usuarios ORDER BY edad DESC; -- Ordenar por múltiples columnas SELECT nombre, edad, fecha_registro FROM usuarios ORDER BY edad DESC, fecha_registro ASC; Cuando ordenás por múltiples columnas, SQL primero ordena por la primera columna, y si hay valores iguales, usa la segunda como criterio de desempate. BETWEEN\rBETWEEN es un operador que te permite filtrar valores dentro de un rango. Es más legible que usar \u003e= y \u003c=: -- Usuarios entre 25 y 35 años SELECT * FROM usuarios WHERE edad BETWEEN 25 AND 35; -- Es equivalente a: SELECT * FROM usuarios WHERE edad \u003e= 25 AND edad \u003c= 35; -- También funciona con fechas SELECT * FROM usuarios WHERE fecha_registro BETWEEN '2025-01-01' AND '2025-03-31'; Importante: BETWEEN es inclusivo, es decir, incluye los valores de inicio y fin del rango. LIMIT\rLIMIT restringe la cantidad de resultados que devuelve la consulta. Es especialmente útil para paginación o cuando solo querés ver una muestra: -- Traer solo los primeros 5 usuarios SELECT * FROM usuarios LIMIT 5; -- Los 3 usuarios más jóvenes SELECT nombre, edad FROM usuarios ORDER BY edad ASC LIMIT 3; -- Paginación: saltar los primeros 10 y traer los siguientes 5 SELECT * FROM usuarios LIMIT 5 OFFSET 10; El OFFSET te permite “saltar” una cantidad de registros, lo que es clave para implementar paginación en aplicaciones. Funciones Agregadas\rLas funciones agregadas procesan múltiples filas y devuelven un único resultado. COUNT()\rCuenta la cantidad de registros: -- Contar todos los usuarios SELECT COUNT(*) FROM usuarios; -- Contar usuarios mayores de 30 SELECT COUNT(*) FROM usuarios WHERE edad \u003e 30; -- Contar valores no nulos en una columna específica SELECT COUNT(email) FROM usuarios; La diferencia entre COUNT(*) y COUNT(columna) es que el primero cuenta todas las filas, mientras que el segundo solo cuenta las filas donde esa columna no es NULL. MAX() y MIN()\rEncuentran el valor máximo y mínimo respectivamente: -- La edad más alta SELECT MAX(edad) FROM usuarios; -- La edad más baja SELECT MIN(edad) FROM usuarios; -- Combinar ambas en una consulta SELECT MAX(edad) AS edad_maxima, MIN(edad) AS edad_minima FROM usuarios; -- También funciona con fechas SELECT MIN(fecha_registro) AS primer_registro FROM usuarios; AVG()\rCalcula el promedio de una columna numérica: -- Edad promedio de los usuarios SELECT AVG(edad) FROM usuarios; -- Promedio de usuarios mayores de 25 SELECT AVG(edad) FROM usuarios WHERE edad \u003e 25; Por defecto, AVG() puede devolver muchos decimales, ahí es donde entra ROUND(). ROUND()\rRedondea un número a la cantidad de decimales que especifiques: -- Edad promedio redondeada a 2 decimales SELECT ROUND(AVG(edad), 2) AS edad_promedio FROM usuarios; -- Sin decimales SELECT ROUND(AVG(edad), 0) AS edad_promedio FROM usuarios; -- También podés redondear cualquier número SELECT ROUND(45.6789, 2); -- Resultado: 45.68 GROUP BY\rGROUP BY agrupa filas que tienen valores iguales en columnas específicas. Casi siempre se usa con funciones agregadas: -- Supongamos que agregamos una columna 'ciudad' a nuestra tabla -- Contar usuarios por ciudad SELECT ciudad, COUNT(*) AS cantidad_usuarios FROM usuarios GROUP BY ciudad; -- Edad promedio por ciudad SELECT ciudad, ROUND(AVG(edad), 1) AS edad_promedio FROM usuarios GROUP BY ciudad; -- Agrupar por múltiples columnas SELECT ciudad, YEAR(fecha_registro) AS anio, COUNT(*) FROM usuarios GR","date":"2025-11-13","objectID":"/posts/fundamentos-sql-parte-2/:0:0","tags":["SQL","Bases de Datos","Curso SQL"],"title":"Curso de SQL - Notas 2: Consultas Avanzadas y Agregaciones","uri":"/posts/fundamentos-sql-parte-2/"},{"categories":null,"content":"En este post voy a compartir los conceptos fundamentales de SQL: desde crear tablas hasta manipular contenido (El típico CRUD).","date":"2025-11-11","objectID":"/posts/fundamentos-sql-parte-1/","tags":["SQL","Bases de Datos","Curso SQL"],"title":"Curso de SQL - Notas 1: Operaciones Básicas","uri":"/posts/fundamentos-sql-parte-1/"},{"categories":null,"content":"Estoy haciendo un curso de Bases de datos y SQL, con el objetivo de ir adelantándome un poco a la carrera que voy a empezar el año que viene. Planeo escribir una serie de posts para ir documentando y compartiendo lo que voy aprendiendo/reforzando sobre el tema. Vamos con el primer post de la serie: SQL (Structured Query Language) es el lenguaje estándar para trabajar con bases de datos relacionales. En esta ocasión, voy a tratar las operaciones fundamentales que necesitás conocer para empezar a trabajar con bases de datos. Crear Tablas\rPara crear una tabla usamos CREATE TABLE, definiendo cada columna con su tipo de dato y restricciones: CREATE TABLE usuarios ( id INT PRIMARY KEY AUTO_INCREMENT, nombre VARCHAR(100) NOT NULL, email VARCHAR(150) UNIQUE, edad INT, fecha_registro DATE ); Los tipos de datos más comunes son INT, VARCHAR, TEXT, DATE, DATETIME, y DECIMAL. Las restricciones como PRIMARY KEY, NOT NULL y UNIQUE nos ayudan a mantener la integridad de los datos, pero de estas voy a hablar más adelante así que no te preocupes. Insertar Registros\rUna vez que tenemos la tabla, podemos agregar datos con INSERT INTO: -- Insertar un solo registro INSERT INTO usuarios (nombre, email, edad, fecha_registro) VALUES ('Juan Pérez', 'juan@email.com', 28, '2025-01-15'); -- Insertar múltiples registros INSERT INTO usuarios (nombre, email, edad, fecha_registro) VALUES ('María García', 'maria@email.com', 32, '2025-02-10'), ('Carlos López', 'carlos@email.com', 25, '2025-03-05'); También se puede omitir el nombre de las columnas, pero vas a tener que respetar el orden en que fueron definidas. En lo personal, me gusta más la primera opción. Seleccionar Registros\rSELECT es probablemente la operación que más vamos a usar. Su sintaxis básica es: -- Seleccionar todas las columnas SELECT * FROM usuarios; -- Seleccionar columnas específicas SELECT nombre, email FROM usuarios; -- Ordenar resultados SELECT nombre, edad FROM usuarios ORDER BY edad DESC; -- Limitar resultados SELECT * FROM usuarios LIMIT 5; El * selecciona todas las columnas de una tabla, dependiendo el caso va a ser útil o no. Si solo necesitamos traer los emails de todos los usuarios, no tendría sentido usar * para traer además todos los otros campos. Supongo que viste las cláusulas ORDER BY, DESC y LIMIT. No te preocupes, aunque son muy intuitivas después vamos a hablar un poco sobre ellas. Actualizar Registros\rPara modificar datos existentes usamos UPDATE: UPDATE usuarios SET edad = 29, email = 'juan.nuevo@email.com' WHERE id = 1; Importante: Siempre usá WHERE al actualizar (al borrar también). Si no lo hacés, vas a modificar todos los registros de la tabla. Es un error común al principio, pero puede causarte bastantes problemas, así que siempre tenemos que asegurarnos que cuando hagamos update, deletes, etc, tengamos el WHERE. Si en el caso anterior no tuviese el WHERE, en vez de cambiar la edad y el mail del usuario con el ID 1, cambiaría la edad y el mail de todos los usuarios de la tabla. Eliminar Registros\rPara borrar registros específicos usamos DELETE: DELETE FROM usuarios WHERE id = 5; Al igual que con UPDATE, el WHERE es crucial. Un DELETE sin WHERE elimina todos los registros de la tabla. La Cláusula WHERE\rWHERE es fundamental para filtrar datos. Podés combinar múltiples condiciones con AND y OR: -- Condición simple - Queremos los usuarios con la edad mayor O igual a 25 SELECT * FROM usuarios WHERE edad \u003e= 25; -- Múltiples condiciones SELECT * FROM usuarios WHERE edad \u003e= 25 AND edad \u003c= 35; -- Usar OR SELECT * FROM usuarios WHERE edad \u003c 20 OR edad \u003e 60; -- Búsqueda con LIKE SELECT * FROM usuarios WHERE nombre LIKE 'Juan%'; El operador LIKE es muy útil para búsquedas de texto. El % funciona como si fuera un comodín. En el caso anterior, le estaríamos diciendo que traiga los usuarios cuyo nombre empiezan con Juan y luego todo lo que sea. Que puede ser nada tranquilamente, o un espacio incluso. Hay que tener en cuenta el orden en el que ponemos el %, no sería lo mismo esto Jua","date":"2025-11-11","objectID":"/posts/fundamentos-sql-parte-1/:0:0","tags":["SQL","Bases de Datos","Curso SQL"],"title":"Curso de SQL - Notas 1: Operaciones Básicas","uri":"/posts/fundamentos-sql-parte-1/"}]